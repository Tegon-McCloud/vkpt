#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "../shader_include/definitions.glsl"
#include "../shader_include/random.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;

struct Camera {
    mat3x3 matrix;
    vec3 position;
};

layout(push_constant) uniform Params {
    Camera camera;
    uint sampleIndex;
} params;

layout(location = 0) rayPayloadEXT pathInfo payload;

void main() {

    ivec2 size = ivec2(gl_LaunchSizeEXT.xy);
    ivec2 position = ivec2(gl_LaunchIDEXT.xy);

    uint launchIndex = position.y * size.x + position.x;
    tea(params.sampleIndex, launchIndex);
    
    vec2 uv = (vec2(position) + vec2(rnd(), rnd())) / vec2(size);

    vec3 origin = params.camera.position;
    vec3 direction = normalize(params.camera.matrix * vec3(uv, 1.0));

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    uint cullMask = 0xff;
    float tMin = 1e-8;
    float tMax = 1e10;

    payload.weight = vec3(1.0);
    payload.radiance = vec3(0.0);

    traceRayEXT(topLevelAS,   // acceleration structure
              rayFlags,       // rayFlags
              cullMask,       // cullMask
              0,              // sbtRecordOffset
              0,              // sbtRecordStride
              0,              // missIndex
              origin,     // ray origin
              tMin,           // ray min range
              direction,  // ray direction
              tMax,           // ray max range
              0               // payload (location = 0)
    );

    float sampleWeight = 1.0 / float(params.sampleIndex + 1);

    vec3 prev = imageLoad(image, position).xyz;
    vec3 new = mix(prev, payload.radiance, sampleWeight);

    imageStore(image, position, vec4(new, 1.0));
}
