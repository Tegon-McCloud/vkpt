#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "../shader_include/definitions.glsl"
#include "../shader_include/util.glsl"
#include "../shader_include/microfacet.glsl"

layout(shaderRecordEXT, std430) buffer sbtData {
    float ior;
    float roughness;
};

layout(location = 0) callableDataInEXT brdfEvaluation evaluation;

vec3 sampleDielectricPhaseFunction2(
    vec3 wi,
    bool outside_i, // is wi on the outside
    out bool outside_o, // is wo on the outside
    float alpha, 
    float alpha_sq,
    float ior_rel, // one over the ior that wi is in 
    inout uint rand_state
) {

    vec3 wm; // in wi's hemisphere

    if (outside_i) {
        wm = sampleVndfGgx(wi, alpha, rand_state);
    } else {
        wm = -sampleVndfGgx(-wi, alpha, rand_state);
    }

    float cos_theta_im = dot(wi, wm);

    float reflectance = 1.0;

    float sin_theta_tm_sq = ior_rel * ior_rel * (1.0 - cos_theta_im * cos_theta_im);
    float cos_theta_tm;

    if (sin_theta_tm_sq < 1.0) {
        cos_theta_tm = sqrt(1.0 - sin_theta_tm_sq);
        reflectance = reflectanceFresnel(cos_theta_im, cos_theta_tm, ior_rel, 1.0);
    }

    float u = rnd(rand_state);
    vec3 wo;

    if(u < reflectance) {
        wo = 2.0 * cos_theta_im * wm - wi;
        outside_o = outside_i;
    } else {
        wo = (ior_rel * cos_theta_im + cos_theta_tm) * wm - ior_rel * wi;
        outside_o = !outside_i;
    }

    return wo;
}

float evalDielectricPhaseFunction(vec3 wi, vec3 wo, bool outside_i, bool outside_o, float alpha_sq, float ior_rel) {

    if (outside_i == outside_o) { // reflection
        
        vec3 wm = normalize(wi + wo); 


    } else { // refraction
        // vec3 wm = -normalize(ior_rel * wi + wo);
        // wm *= (wi_outside) ? (sign(wm.z)) : (-sign(wm.z));

        // float cos_theta_im = dot(wm, wi);
        // float cos_theta_tm = dot(wm, wo);

        // if (cos_theta_im < 0.0) {
        //     return 0.0;
        // }

        // float value;

        // if (wi_outside) {

        //     float reflectance = reflectanceFresnel(cos_theta_im, , 1.0, ior_rel);

        //     (1.0 - reflectance) * vndfGgx(wi, wm, alpha_sq) * max(0.0, -dot(wo, wm)) * 

        // }
        
        

    }



    return 0.0;

} 

float randomWalk(vec3 w, vec3 wo) {

    float alpha = roughness;
    float alpha_sq = alpha * alpha;

    float sum = 0.0;

    bool wo_outside = wo.z > 0.0;
    bool outside = w.z < 0.0;

    float height = 1.0 + invHeightCdfUniform(0.999);

    for (int i = 0; i < 32; i++) {

        bool escaped;

        if(outside) {
            height = sampleHeightGgxUniform(w, height, escaped, alpha_sq, evaluation.rand_state);
        } else {
            height = -sampleHeightGgxUniform(-w, -height, escaped, alpha_sq, evaluation.rand_state);
        }

        if (escaped) {
            break;
        }

        w = sampleDielectricPhaseFunction2(
            -w,
            outside,
            outside,
            alpha,
            alpha_sq,
            outside ? 1.0 / ior : ior,
            evaluation.rand_state
        );
    }

    return sum;
}

void main() {

    vec3 w = -evaluation.wi;
    vec3 wo = evaluation.wo;

    evaluation.weight = vec3(randomWalk(w, wo));
}