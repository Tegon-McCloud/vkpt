#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "../shader_include/definitions.glsl"
#include "../shader_include/util.glsl"
#include "../shader_include/microfacet.glsl"

layout(shaderRecordEXT, std430) buffer sbtData {
    float ior;
    float roughness;
};

layout(location = 0) callableDataInEXT brdfEvaluation evaluation;

vec3 sampleDielectricPhaseFunction(vec3 wo, inout float weight, float alpha, float ior_rel, bool outside, out bool transmitted) {

    vec3 wm;

    if (outside) {
        wm = sampleVndfGgx(wo, alpha, evaluation.rand_state);
    } else {
        wm = sampleVndfGgx(-wo, alpha, evaluation.rand_state);
    }

    float cos_theta_om = dot(wo, wm);

    float reflectance = 1.0;

    float sin_theta_tm_sq = ior_rel * ior_rel * (1.0 - cos_theta_om * cos_theta_om);
    float cos_theta_tm;

    if (sin_theta_tm_sq < 1.0) {
        cos_theta_tm = sqrt(1.0 - sin_theta_tm_sq);
        reflectance = reflectanceFresnel(abs(cos_theta_om), cos_theta_tm, ior_rel, 1.0);
    }

    vec3 wi;

    if (rnd(evaluation.rand_state) < reflectance) {
        wi = 2.0 * dot(wo, wm) * wm - wo;
        transmitted = false;
    } else {
        wi = (ior_rel * cos_theta_om - sign(wo.z) * cos_theta_tm) * wm - ior_rel * wo;
        transmitted = true;
    }
    
    return wi;
}

void main() {

    float alpha = roughness;    
    float alpha_sq = alpha * alpha;

    bool outside = evaluation.wo.z > 0.0;    
    bool started_outside = outside;

    
    float ior_rel;

    if (outside) {
        ior_rel = 1.0 / ior;
    } else {
        ior_rel = ior;
    }

    vec3 w = -evaluation.wo;
    float height = 0.0;
    float weight = 1.0;

    for(int i = 0; i < 8; i++) {

        float extinction = lambdaGgx(w.z, alpha_sq) * w.z;
        float dist = sampleExponential(extinction, evaluation.rand_state);

        height += w.z * dist;

        if(height > 0.0) {
            evaluation.wi = w;

            if(outside != started_outside) {
                evaluation.wi.z = -evaluation.wi.z;
            }

            evaluation.weight = vec3(weight);
            return;
        }

        bool transmitted;
        w = sampleDielectricPhaseFunction(-w, weight, alpha, ior_rel, outside, transmitted);

        if(transmitted) {
            outside = !outside;
            ior_rel = 1.0 / ior_rel;

            float xi = invHeightCdfUniform(exp(height));
            height = log(heightCdfUniform(-xi));

            w.z = -w.z;
        }
    }

    evaluation.wi = vec3(0.0);
    evaluation.weight = vec3(0.0);
}