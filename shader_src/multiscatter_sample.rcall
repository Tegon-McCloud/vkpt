#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "../shader_include/definitions.glsl"
#include "../shader_include/util.glsl"
#include "../shader_include/microfacet.glsl"

layout(shaderRecordEXT, std430) buffer sbtData {
    float ior;
    float roughness;
};

layout(location = 0) callableDataInEXT brdfEvaluation evaluation;

void main() {
    float alpha = roughness;    
    float alpha_sq = alpha * alpha;

    vec3 w = -evaluation.wo;
    float height = 0.0;
    float weight = 1.0;

    for(int i = 0; i < 8; i++) {

        float extinction = lambdaGgx(w.z, alpha_sq) * w.z;
        float dist = sampleExponential(extinction, evaluation.rand_state);

        // if (extinction < 0.0) {
        //     evaluation.wi = vec3(0.0, 0.0, 1.0);
        //     evaluation.weight = vec3(100.0, 0.0, 0.0);
        //     return;
        // }

        height += w.z * dist;

        if(height > 0.0) {
            evaluation.wi = w;
            evaluation.weight = vec3(weight);
            return;
        }

        vec3 wm = sampleVndfGgx(-w, alpha, evaluation.rand_state);
        
        // if(dot(w, wm) > 1e-3) {
        //     evaluation.wi = vec3(0.0, 0.0, 1.0);
        //     evaluation.weight = vec3(100.0, 0.0, 0.0);
        //     return;
        // }

        float cos_theta_im = dot(-w, wm);

        w = w + 2.0 * cos_theta_im * wm;

        // if(abs(length(w) - 1.0) > 1e-5) {
        //     evaluation.wi = vec3(0.0, 0.0, 1.0);
        //     evaluation.weight = vec3(100.0, 0.0, 100.0);
        //     return;
        // }

        extinction  = lambdaGgx(w.z, alpha_sq) * w.z;
        dist = sampleExponential(extinction, evaluation.rand_state);

        height += w.z * dist;
    }

    evaluation.wi = vec3(0.0);
    evaluation.weight = vec3(0.0);
}