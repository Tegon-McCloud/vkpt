#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "../shader_include/definitions.glsl"
#include "../shader_include/util.glsl"
#include "../shader_include/microfacet.glsl"

layout(shaderRecordEXT, std430) buffer sbtData {
    float ior;
    float roughness;
};

layout(location = 0) callableDataInEXT brdfEvaluation evaluation;


vec3 sampleVndfGgx2(vec3 wi, float alpha, inout uint rand_state) {
    vec3 wi_std = normalize(vec3(wi.xy * alpha, wi.z));

    float phi = 2.0 * pi * rnd(rand_state);

    float z = (1.0 - rnd(rand_state)) * (1.0 + wi_std.z) - wi_std.z;
    float sin_theta = sqrt(max(1.0 - z * z, 0.0));
    float x = sin_theta * cos(phi);
    float y = sin_theta * sin(phi);

    vec3 wm_std = wi_std + vec3(x, y, z); // unnormalized!

    return normalize(vec3(wm_std.xy * alpha, wm_std.z));
}

vec3 sampleDielectricPhaseFunction2(
    vec3 wi,
    bool outside_i, // is wi on the outside?
    out bool outside_o, // is wo on the outside?
    float alpha, 
    float alpha_sq,
    float ior_rel, // one over the ior that wi is in 
    inout uint rand_state
) {
    vec3 wm;

    if (outside_i) {
        wm = sampleVndfGgx2(wi, alpha, rand_state);
    } else {
        wm = -sampleVndfGgx2(-wi, alpha, rand_state);

        // if (-wm.z < 0.0) {
        //     evaluation.error_state = 1;
        // }
    }

    float cos_theta_im = dot(wi, wm);

    float reflectance = 1.0;

    float sin_theta_tm_sq = ior_rel * ior_rel * (1.0 - cos_theta_im * cos_theta_im);
    float cos_theta_tm;

    if (sin_theta_tm_sq < 1.0) {
        cos_theta_tm = sqrt(1.0 - sin_theta_tm_sq);
        reflectance = reflectanceFresnel(cos_theta_im, cos_theta_tm, ior_rel, 1.0);
    }

    float u = rnd(rand_state);
    vec3 wo;

    if(u < reflectance) {
        wo = 2.0 * cos_theta_im * wm - wi;
        outside_o = outside_i;
    } else {
        wo = (ior_rel * cos_theta_im - cos_theta_tm) * wm - ior_rel * wi;
        outside_o = !outside_i;
    }

    return wo;
}

vec3 randomWalk(vec3 w) {

    float alpha = roughness;
    float alpha_sq = alpha * alpha;

    bool outside = w.z < 0.0;

    float height = 1.0 + invHeightCdfUniform(0.999);
    
    for (int i = 0; i < 32; i++) {

        bool escaped;

        if(outside) {
            height = sampleHeightGgxUniform(w, height, escaped, alpha_sq, evaluation.rand_state);
        } else {
            height = -sampleHeightGgxUniform(-w, -height, escaped, alpha_sq, evaluation.rand_state);
        }

        if (escaped) {
            return w;
        }

        w = sampleDielectricPhaseFunction2(
            -w,
            outside,
            outside,
            alpha,
            alpha_sq,
            outside ? 1.0 / ior : ior,
            evaluation.rand_state
        );
    }

    return vec3(0.0);
}

void main() {
    vec3 w = -evaluation.wo;
    evaluation.wi = randomWalk(w);
    evaluation.weight = vec3(1.0);
}

// vec3 randomWalk(vec3 w, inout float weight, float alpha, float alpha_sq, float ior_rel) {
//     float height = 1.0 + invHeightCdfUniform(0.999);

//     bool outside = w.z < 0.0;

//     if (!outside) {
//         w.z = -w.z;
//     }

//     for (int i = 0; i < 32; i++) {

//         bool escaped;

//         height = sampleHeightGgxUniform(w, height, escaped, alpha_sq, evaluation.rand_state);

//         if (escaped) {
//             if (!outside) {
//                 w.z = -w.z;
//             }

//             return w;
//         }

//         bool transmitted;

//         w = sampleDielectricPhaseFunction(
//             -w,
//             weight,
//             transmitted,
//             alpha,
//             outside ? ior_rel : 1.0 / ior_rel,
//             evaluation.rand_state
//         );

//         if(transmitted) {
//             w.z = -w.z;
//             height = -height;
//             outside = !outside;
//         }
//     }

//     return vec3(0.0);
// }

// void main() {


//     float alpha = roughness;    
//     float alpha_sq = alpha * alpha;

//     float weight = 1.0;

//     vec3 w = -evaluation.wo;
//     float ior_rel = 1.0 / ior;

//     w = randomWalk(w, weight, alpha, alpha_sq, ior_rel);

//     if (w == vec3(0.0)) {
//         evaluation.wi = vec3(0.0);
//         evaluation.weight = vec3(0.0);
//         return;
//     }

//     evaluation.wi = w;
//     evaluation.weight = vec3(weight);
// }